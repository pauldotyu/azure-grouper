# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml


trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
- group: kvdevops1

stages:
- stage: plan
  displayName: Plan
  condition: and(ne(variables.namespace, ''), eq(variables.destroy, false))
  jobs:
  - job: terraform_plan
    displayName: Terraform Plan
    steps:
    - script: |
        echo "##vso[task.setvariable variable=PSQL_PASSWORD_GROUPER_ENCRYPTED;]$(java -cp .:grouperClient-2.5.39.jar edu.internet2.middleware.morphString.Encrypt dontMask <<< $(psql-password) | sed 's/Type the string to encrypt (note: pasting might echo it back): The encrypted string is: //')"
      displayName: Grouper encrypt passwords
      name: grouper_encrypt
      workingDirectory: slashRoot/opt/grouper/grouperWebapp/WEB-INF/classes
    - task: DownloadSecureFile@1
      name: terraformrc
      displayName: 'Download .terraformrc'
      inputs:
        secureFile: '.terraformrc'
    - script: |
        export ARM_CLIENT_ID=$(client-id)
        export ARM_CLIENT_SECRET=$(client-secret)
        export ARM_SUBSCRIPTION_ID=$(main-subscription-id)
        export ARM_TENANT_ID=$(tenant-id)
        export TF_CLI_CONFIG_FILE="$(terraformrc.secureFilePath)"
        terraform init
        terraform plan -var-file="$(namespace).tfvars" -var="psql_login=$(psql-user)" -var="psql_password=$(psql-password)" -var="psql_password_grouper_encrypted=$(PSQL_PASSWORD_GROUPER_ENCRYPTED)" -var="aks_admin_group_object_id=$(aks-admin-group-object-id)" -out=$(System.DefaultWorkingDirectory)/$(namespace).tfplan
      displayName: Terraform Plan
      name: terraform_plan
      workingDirectory: terraform
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(System.DefaultWorkingDirectory)/$(namespace).tfplan'
        artifactName: 'tfplan'
      displayName: Publish $(namespace).tfplan
      name: publish_tfplan
- stage: build
  displayName: Build
  condition: eq(dependencies.plan.result, 'Succeeded')
  dependsOn: plan
  jobs:
  - job: review_plan
    displayName: Review Plan
    pool: Server
    steps:
    - task: ManualValidation@0
      inputs:
        notifyUsers: $(notifyUsers)
        instructions: 'Have you taken a look at the terraform plan output?'
      displayName: Review Plan
      name: review_plan
  - job: apply
    displayName: Terraform Apply
    condition: eq(dependencies.review_plan.result, 'Succeeded')
    dependsOn: review_plan
    steps:
    - task: DownloadSecureFile@1
      name: terraformrc
      displayName: 'Download .terraformrc'
      inputs:
        secureFile: '.terraformrc'
    - task: DownloadPipelineArtifact@2
      inputs:
        artifactName: tfplan
        patterns: '**/*.tfplan'
        path: $(System.DefaultWorkingDirectory)
      displayName: Download $(namespace).tfplan
      name: download_tfplan
    - script: |
        export ARM_CLIENT_ID=$(client-id)
        export ARM_CLIENT_SECRET=$(client-secret)
        export ARM_SUBSCRIPTION_ID=$(main-subscription-id)
        export ARM_TENANT_ID=$(tenant-id)
        export TF_CLI_CONFIG_FILE="$(terraformrc.secureFilePath)"
        terraform init
        terraform apply --auto-approve $(System.DefaultWorkingDirectory)/$(namespace).tfplan
        echo "##vso[task.setvariable variable=RG_NAME;isOutput=true]$(terraform output -raw rg_name)"
        echo "##vso[task.setvariable variable=ACR_NAME;isOutput=true]$(terraform output -raw acr_name)"
        echo "##vso[task.setvariable variable=AKS_NAME;isOutput=true]$(terraform output -raw aks_name)"
        echo "##vso[task.setvariable variable=AKV_NAME;isOutput=true]$(terraform output -raw akv_name)"
        echo "##vso[task.setvariable variable=MANAGED_IDENTITY_CLIENT_ID;isOutput=true]$(terraform output -raw aks_managed_identity_client_id)"
        echo "##vso[task.setvariable variable=MANAGED_IDENTITY_RESOURCE_ID;isOutput=true]$(terraform output -raw aks_managed_identity_resource_id)"
      displayName: Terraform Apply
      name: apply
      workingDirectory: terraform
  - job: acr_build
    displayName: ACR Build
    condition: eq(dependencies.apply.result, 'Succeeded')
    dependsOn: apply
    variables:
      CONTAINER_VERSION: '$(Build.BuildId)'
      RG_NAME: $[ dependencies.apply.outputs['apply.RG_NAME'] ]
      ACR_NAME: $[ dependencies.apply.outputs['apply.ACR_NAME'] ]
    steps:
    - script: |
        sed -i "s~<YOUR_GROUPER_SYSTEM_PASSWORD>~$(grouper-system-password)~ " ./slashRoot/opt/grouper/grouperWebapp/WEB-INF/bin/assignGrouperSystemPassword.gsh; chmod +x ./slashRoot/opt/grouper/grouperWebapp/WEB-INF/bin/assignGrouperSystemPassword.gsh
        az login --service-principal --username $(client-id) --password $(client-secret) --tenant $(tenant-id)
        az account set -s $(main-subscription-id)
        az acr build --registry $(ACR_NAME) --resource-group $(RG_NAME) --image grouper:$(CONTAINER_VERSION) .
      displayName: Container Build
      name: acr_build
  - job: aks_features
    displayName: Enable AKS Features
    condition: eq(dependencies.acr_build.result, 'Succeeded')
    dependsOn:
      - apply
      - acr_build
    variables:
      RG_NAME: $[ dependencies.apply.outputs['apply.RG_NAME'] ]
      AKS_NAME: $[ dependencies.apply.outputs['apply.AKS_NAME'] ]
      MANAGED_IDENTITY_RESOURCE_ID: $[ dependencies.apply.outputs['apply.MANAGED_IDENTITY_RESOURCE_ID'] ]
    steps:
    - script: |
        az login --service-principal --username $(client-id) --password $(client-secret) --tenant $(tenant-id)
        az account set -s $(main-subscription-id)
        az aks get-credentials -n $(AKS_NAME) -g $(RG_NAME) --admin
        az provider register --namespace Microsoft.ContainerService
        az feature register --name EnablePodIdentityPreview --namespace Microsoft.ContainerService
        az feature register --name AKS-AzureKeyVaultSecretsProvider --namespace Microsoft.ContainerService
        az extension add --name aks-preview
        az extension update --name aks-preview

        # Enable Azure Key Vault provider for Secrets Store CSI driver (CSI driver)
        csi=$(az aks show -g $RG_NAME -n $AKS_NAME --query addonProfiles.azureKeyvaultSecretsProvider.enabled)
        if [ -z "$csi" ] || [ "$csi" == "false" ]
        then
              echo "addonProfiles.azureKeyvaultSecretsProvider being enabling now..."
              az aks enable-addons -g $RG_NAME -n $AKS_NAME -a azure-keyvault-secrets-provider
        else
              echo "addonProfiles.azureKeyvaultSecretsProvider already enabled"
        fi

        # Enable Azure AD Pod Identity
        pod=$(az aks show -g $RG_NAME -n $AKS_NAME --query podIdentityProfile.enabled)
        if [ -z "$pod" ] || [ "$pod" == "false" ]
        then
              echo "podIdentityProfile being enabling now..."
              az aks update -g $RG_NAME -n $AKS_NAME --enable-pod-identity
              POD_IDENTITY_NAME=grouper-pod-identity
              az aks pod-identity add -g $RG_NAME --cluster-name $AKS_NAME --namespace $(namespace) --name $POD_IDENTITY_NAME --identity-resource-id $(MANAGED_IDENTITY_RESOURCE_ID)
        else
              echo "podIdentityProfile already enabled"
        fi
      displayName: Enable AKS add-ons
      name: enable_aks_features
  - job: kubectl
    displayName: Apply Kubernetes Manifests
    condition: and(eq(dependencies.apply.result, 'Succeeded'), eq(dependencies.aks_features.result, 'Succeeded'))
    dependsOn:
      - apply
      - aks_features
    variables:
      CONTAINER_VERSION: '$(Build.BuildId)'
      RG_NAME: $[ dependencies.apply.outputs['apply.RG_NAME'] ]
      ACR_NAME: $[ dependencies.apply.outputs['apply.ACR_NAME'] ]
      AKS_NAME: $[ dependencies.apply.outputs['apply.AKS_NAME'] ]
      AKV_NAME: $[ dependencies.apply.outputs['apply.AKV_NAME'] ]
      MANAGED_IDENTITY_CLIENT_ID: $[ dependencies.apply.outputs['apply.MANAGED_IDENTITY_CLIENT_ID'] ]
    steps:
    - script: |
        sed -i "s/<YOUR_KV_NAME>/$(AKV_NAME)/; s/<YOUR_KV_TENANT_ID>/$(tenant-id)/" grouper-secrets-provider.yml
        sed -i "s/<YOUR_ACR_NAME>/$(ACR_NAME)/; s/<YOUR_CONTAINER_VERSION>/$(CONTAINER_VERSION)/" grouper-daemon.yml
        sed -i "s/<YOUR_ACR_NAME>/$(ACR_NAME)/; s/<YOUR_CONTAINER_VERSION>/$(CONTAINER_VERSION)/" grouper-ws.yml
        sed -i "s/<YOUR_ACR_NAME>/$(ACR_NAME)/; s/<YOUR_CONTAINER_VERSION>/$(CONTAINER_VERSION)/" grouper-ui.yml
      displayName: Update Kubernetes Manifests
      name: update_manifests
      workingDirectory: kubernetes
    - script: |
        az login --service-principal --username $(client-id) --password $(client-secret) --tenant $(tenant-id)
        az account set -s $(main-subscription-id)
        az aks get-credentials --resource-group $(RG_NAME) --name $(AKS_NAME) --admin
        kubectl create namespace $(namespace) --dry-run=client -o yaml | kubectl apply -f -
        kubectl apply -f grouper-secrets-provider.yml -n $(namespace)
        kubectl apply -f grouper-daemon.yml -n $(namespace)
        kubectl apply -f grouper-ws.yml -n $(namespace)
        kubectl apply -f grouper-ui.yml -n $(namespace)
        kubectl get all -n $(namespace)
      displayName: Apply Kubernetes Manifests
      name: kubectl_apply
      workingDirectory: kubernetes
- stage: destroy
  displayName: Destroy
  condition: and(ne(variables.namespace, ''), eq(variables.destroy, true))
  jobs:
  - job: do_destroy
    displayName: Destroy
    pool: Server
    steps:
    - task: ManualValidation@0
      inputs:
        notifyUsers: $(notifyUsers)
        instructions: 'You sure you want to destroy?'
      name: do_destroy
  - job: terraform_destroy
    displayName: Terraform Destroy
    condition: eq(dependencies.do_destroy.result, 'Succeeded')
    dependsOn: do_destroy
    steps:
    - task: DownloadSecureFile@1
      name: terraformrc
      displayName: 'Download .terraformrc'
      inputs:
        secureFile: '.terraformrc'
    - script: |
        export ARM_CLIENT_ID=$(client-id)
        export ARM_CLIENT_SECRET=$(client-secret)
        export ARM_SUBSCRIPTION_ID=$(main-subscription-id)
        export ARM_TENANT_ID=$(tenant-id)
        export TF_CLI_CONFIG_FILE="$(terraformrc.secureFilePath)"
        terraform init
        terraform destroy -var-file="$(namespace).tfvars" -var="psql_login=$(psql-user)" -var="psql_password=$(psql-password)" -var="psql_password_grouper_encrypted=$(PSQL_PASSWORD_GROUPER_ENCRYPTED)" -var="aks_admin_group_object_id=$(aks-admin-group-object-id)" --auto-approve
      displayName: Destroy infrastructure
      workingDirectory: terraform
